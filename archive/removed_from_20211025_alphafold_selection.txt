"source": [
    "# #Extract CDS for all genes in orthogroup: \n",
    "\n",
    "# target_og = 'OG1390'\n",
    "    \n",
    "# # Gather CDS sequences into one fasta\n",
    "# cds_all_fasta_out_fname = base_dir + os.sep + target_og + '_all_cds.fasta'\n",
    "\n",
    "# spec_orig_genome_lookup\n",
    "\n",
    "# og_genes = og_genes_lookup[target_og]\n",
    "\n",
    "# y1000plus_tools.extract_cds_seqs(og_genes, cds_all_fasta_out_fname, y1000_species)\n",
    "# print(protein_fname + ' cds sequence extraction complete')\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# #the following information is in the fasta header for each protein\n",
    "# #<spec_orig_genome>__<og>__<y1000_id>: you can use this to look up other metadata in the og_metadata.json file\n",
    "# #source:  The source of the peptide sequence (either 'shen' or 'uniprot')\n",
    "# #gene_full:  The full name of the gene from source peptide file\n",
    "# #gene_full_shen: the full name of the gene from the shen peptide file\n",
    "# #L: Length of the gene\n",
    "# #sim_score_vs_shen: The similarity score between the shen peptide sequence and the uniprot peptide sequence.  If it is above the threshold, the uniprot sequence is used, below the threshold, we continue to use the shen sequence\n",
    "# #sim_score_vs_shen_diff: The difference between similarity score of the top peptide and the second highest scoring peptide.  For genes with similarity score below a threshold, if this difference is too small, we keep the shen sequence\n",
    "\n",
    "# shen_proteome_dir = os.path.normpath(y1000plus_dir + 'shen_2018_data/0_332yeast_genomes/332_genome_annotations/pep') + os.sep \n",
    "# uniprot_proteome_dir = os.path.normpath('C:/Users/heineib/Google Drive/Crick_LMS/external_data/genomes/diverse_yeast/proteomes') + os.sep \n",
    "\n",
    "# #(species genome name: (shen_fname, uniprot_fname)): \n",
    "# proteome_fasta_dict = {'kluyveromyces_lactis': {'shen': shen_proteome_dir + 'kluyveromyces_lactis.max.pep', \n",
    "#                                                 'uniprot': uniprot_proteome_dir + 'Klac_uniprot-proteome_UP000000598.fasta'\n",
    "#                                                }, \n",
    "#                        'wickerhamomyces_anomalus': {'shen': shen_proteome_dir + 'wickerhamomyces_anomalus.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Wano_uniprot-proteome_UP000094112.fasta'\n",
    "#                            }, \n",
    "#                        'lachancea_thermotolerans': {'shen': shen_proteome_dir + 'lachancea_thermotolerans.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Lthe_uniprot-proteome_UP000002036.fasta'\n",
    "#                            }, \n",
    "#                        'komagataella_pastoris': {'shen': shen_proteome_dir + 'komagataella_pastoris.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Kpas_uniprot-proteome_UP000000314.fasta'\n",
    "#                            }, \n",
    "#                         'candida_tropicalis': {'shen': shen_proteome_dir + 'candida_tropicalis.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Ctro_uniprot-proteome_UP000002037.fasta'\n",
    "#                            },\n",
    "#                         'debaryomyces_hansenii': {'shen': shen_proteome_dir + 'debaryomyces_hansenii.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Dhan_uniprot-proteome_UP000000599.fasta'\n",
    "#                            }, \n",
    "#                         'yHMPu5000034957_hanseniaspora_osmophila_160519': {'shen': shen_proteome_dir + 'yHMPu5000034957_hanseniaspora_osmophila_160519.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Hosm_uniprot-proteome_UP000095728.fasta'\n",
    "#                            }, \n",
    "#                         'kluyveromyces_marxianus': {'shen': shen_proteome_dir + 'kluyveromyces_marxianus.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Kmar_uniprot-proteome_UP000065495.fasta'\n",
    "#                            }, \n",
    "#                         'zygosaccharomyces_rouxii': {'shen': shen_proteome_dir + 'zygosaccharomyces_rouxii.max.pep',\n",
    "#                             'uniprot': uniprot_proteome_dir + 'Zrou_uniprot-proteome_UP000008536.fasta'\n",
    "#                            }\n",
    "#                       }\n",
    "\n",
    "\n",
    "# sim_score_high_thresh = 75\n",
    "# sim_score_low_thresh = 60\n",
    "# sim_score_diff_thresh = 8\n",
    "\n",
    "\n",
    "# with open(fasta_out_fname, 'w') as f_out: \n",
    "\n",
    "#     #for each species: \n",
    "#     for spec_id, spec_name in spec_id_map.items(): \n",
    "#         spec = spec_id_map[spec_id]\n",
    "\n",
    "#         spec_orig_genome = spec_orig_genome_lookup[spec_id]\n",
    "#         print(spec_orig_genome)\n",
    "        \n",
    "#         if spec_orig_genome in {'saccharomyces_cerevisiae', 'candida_albicans'}: \n",
    "#             print('skipping ' + spec_orig_genome)\n",
    "#             #Skip this species\n",
    "#         elif spec_orig_genome in proteome_fasta_dict.keys():\n",
    "#             #Attempt to convert to uniprot fasta  \n",
    "#             print('checking to see if uniprot or shen et al sequences should be used')\n",
    "#             source = 'uniprot'\n",
    "            \n",
    "#             protein_fname_uniprot = proteome_fasta_dict[spec_orig_genome]['uniprot']\n",
    "#             seq_records_uniprot = SeqIO.parse(protein_fname_uniprot, \"fasta\")\n",
    "#             pairwise_scores_spec = pairwise_scores[spec_orig_genome]\n",
    "            \n",
    "#             protein_fname_shen = proteome_fasta_dict[spec_orig_genome]['shen']\n",
    "#             seq_records_shen = SeqIO.parse(protein_fname_shen, \"fasta\")\n",
    "        \n",
    "#             spec_lookup_fname = y1000plus_dir + os.path.normpath('y1000plus_tools_data/y1000plus/id_lookups/' + spec_orig_genome + '.csv')\n",
    "#             spec_lookup = pd.read_csv(spec_lookup_fname, index_col=0)\n",
    "\n",
    "# #             if spec_orig_genome == 'saccharomyces_cerevisiae':\n",
    "# #                 #for S. cerevisiae the orf name is the 'gene_full'\n",
    "# #                 gene_full_y1000_id_lookup = dict(zip(spec_lookup['y1000_id'], spec_lookup.index))\n",
    "# #             else: \n",
    "#             gene_full_y1000_id_lookup = dict(zip(spec_lookup['y1000_id'], spec_lookup['gene_full']))\n",
    "\n",
    "#             #for each orthogroup:\n",
    "#             #Identify whether the proteins will be unipro or shen \n",
    "#             seqs_to_get_uniprot = {} #gene_full_uniprot: (y1000_id, og, maxval, diff_top2_val, gene_full_shen)\n",
    "#             seqs_to_get_shen = {}  #gene_full_shen: (y1000_id, og, maxval, diff_top2_val)\n",
    "#             gene_full_set_uniprot = []\n",
    "#             gene_full_set_shen = []\n",
    "#             for og, (N_genes, pct_present, og_genes_out) in og_out_data.items():\n",
    "#                 for y1000_id in og_genes_out: \n",
    "#                     spec_id_check = int(y1000_id.split('_')[0])\n",
    "#                     if spec_id_check==spec_id:\n",
    "#                         gene_full_shen = gene_full_y1000_id_lookup[y1000_id]\n",
    "#                         pairwise_score_gene = pairwise_scores_spec[gene_full_shen]\n",
    "                        \n",
    "#                         #Check to see if pairwise scores pass filters: \n",
    "#                         options_sorted = pairwise_score_gene.sort_values(ascending=False)  #possible that they are already sorted and this is unnecessary\n",
    "#                         maxval = options_sorted[0]\n",
    "#                         diff_top2_val = maxval-options_sorted[1]\n",
    "                        \n",
    "#                         if ((maxval>sim_score_high_thresh) | ((maxval>sim_score_low_thresh) & (diff_top2_val>sim_score_diff_thresh))): \n",
    "#                             gene_full_uniprot = options_sorted.index[0]\n",
    "#                             seqs_to_get_uniprot[gene_full_uniprot] = (y1000_id, og, maxval, diff_top2_val, gene_full_shen)\n",
    "#                             gene_full_set_uniprot.append(gene_full_uniprot)\n",
    "#                         else: \n",
    "#                             seqs_to_get_shen[gene_full_shen] = (y1000_id, og, maxval, diff_top2_val)\n",
    "#                             gene_full_set_shen.append(gene_full_shen)\n",
    "                                      \n",
    "#             #Cycle through uniprot proteome and print to fasta if it is in the set. \n",
    "#             seq_record_fasta_printout(seq_records_uniprot, f_out, gene_full_set_uniprot, seqs_to_get_uniprot, 'uniprot', spec_orig_genome)\n",
    "                              \n",
    "#             #Cycle through shen proteome and print to fasta if it is in the set. \n",
    "#             seq_record_fasta_printout(seq_records_shen, f_out, gene_full_set_shen, seqs_to_get_shen, 'shen', spec_orig_genome)\n",
    "\n",
    "        \n",
    "        \n",
    "#         else: \n",
    "#             print('using shen et al sequence')\n",
    "#             fasta_extract_shen(f,shen_proteome_dir, spec_orig_genome, y1000plus_dir, og_out_data)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# fname = cds_fasta_out_fname\n",
    "# y1000_species_subset = y1000_species\n",
    "\n",
    "# # def extract_cds_seqs(og_genes, fname, y1000_species_subset): \n",
    "# #     #Looks up coding sequences for given list of orthogroup genes \n",
    "# #     #\n",
    "# #     ## Does not work for outgroup species\n",
    "\n",
    "# #     #os.mkdir(y1000plus_dir + os.path.normpath('y1000plus_tools_data/y1000plus/proteins_og/' + fname))\n",
    "# #     #proteins_og_fname = y1000plus_dir + os.path.normpath('y1000plus_tools_data/y1000plus/proteins_og/' + fname + '/' + fname + '.fasta')\n",
    "\n",
    "# #     genome_name_lookup = dict(zip(y1000_species_subset['spec_og_id'],y1000_species_subset['original_genome_id']))\n",
    "\n",
    "# #     with open(fname,'w') as f: \n",
    "# #         # group by species\n",
    "# #         og_genes_specs = {spec_gene.split('_')[0]: [] for spec_gene in og_genes}\n",
    "# #         for y1000_id in og_genes: \n",
    "# #             spec_og_id = y1000_id.split('_')[0]\n",
    "# #             og_genes_specs[spec_og_id].append(y1000_id)\n",
    "\n",
    "# #         for spec_og_id, genes in og_genes_specs.items(): \n",
    "# #             genome_name = genome_name_lookup[int(spec_og_id)]\n",
    "# #             print(genome_name)\n",
    "# #             #if S.Cer or C. Albicans, do slightly different routine\n",
    "\n",
    "# #             if genome_name == 'saccharomyces_cerevisiae':\n",
    "# #                 #load gene_id map based on the species\n",
    "# #                 gene_lookup_spec_fname = y1000plus_dir + os.path.normpath(\"y1000plus_tools_data/y1000plus/id_lookups/\" + genome_name + '.csv')\n",
    "# #                 gene_lookup_spec = pd.read_csv(gene_lookup_spec_fname, index_col='y1000_id')\n",
    "\n",
    "# #                 cds_fname = y1000plus_dir + os.path.normpath('shen_2018_data/0_332yeast_genomes/332_genome_annotations/Saccharomyces_cerevisiae_S288C_coding.fasta')\n",
    "\n",
    "# #                 seq_records = SeqIO.parse(cds_fname, \"fasta\")\n",
    "\n",
    "# #                 genes_lookup = gene_lookup_spec.loc[genes]\n",
    "# #                 genes_lookup_set = set(gene_lookup_spec.loc[genes,'gene_id'].values)  #SC specific\n",
    "\n",
    "# #                 for seq_record in seq_records:\n",
    "# #                     gene_id = seq_record.description.split()[0] #SC specific\n",
    "# #                     #print(gene_full)\n",
    "# #                     if (gene_id in genes_lookup_set):\n",
    "# #                         #find which y1000_id was matched\n",
    "# #                         y1000_rlookup = (genes_lookup['gene_id'] == gene_id)\n",
    "# #                         for gene, tf in y1000_rlookup.items(): \n",
    "# #                             if tf:\n",
    "# #                                 y1000_id=gene\n",
    "# #                         cds_seq = seq_record.seq\n",
    "# #                         f.write('>' + genome_name + '_' + gene_id + ' y1000_id=' + y1000_id + ' gene_id=' + gene_id +\n",
    "# #                                 ' common_name=' + seq_record.description.split()[1] + #this adds in the cds from the original description\n",
    "# #                                 '\\n')\n",
    "# #                         f.write(str(cds_seq) + '\\n')  \n",
    "# #             elif genome_name == 'candida_albicans':\n",
    "# #                 #load gene_id map based on the species\n",
    "# #                 gene_lookup_spec_fname = y1000plus_dir + os.path.normpath(\"y1000plus_tools_data/y1000plus/id_lookups/\" + genome_name + '.csv')\n",
    "# #                 gene_lookup_spec = pd.read_csv(gene_lookup_spec_fname, index_col='y1000_id')\n",
    "\n",
    "# #                 cds_fname = y1000plus_dir + os.path.normpath('shen_2018_data/0_332yeast_genomes/332_genome_annotations/Candida_albicans_SC5314_A22_current_default_coding.fasta')\n",
    "# #                 seq_records = SeqIO.parse(cds_fname, \"fasta\")\n",
    "\n",
    "# #                 genes_lookup = gene_lookup_spec.loc[genes]\n",
    "# #                 genes_lookup_set = set(gene_lookup_spec.loc[genes,'gene_id'].values)  \n",
    "\n",
    "# #                 for seq_record in seq_records:\n",
    "# #                     gene_id = seq_record.description \n",
    "\n",
    "# #                     if (gene_id in genes_lookup_set):\n",
    "# #                         #find which y1000_id was matched\n",
    "# #                         y1000_rlookup = (genes_lookup['gene_id'] == gene_id)\n",
    "# #                         for gene, tf in y1000_rlookup.items(): \n",
    "# #                             if tf:\n",
    "# #                                 y1000_id=gene\n",
    "# #                         cds_seq = seq_record.seq\n",
    "# #                         f.write('>' + genome_name + '_' + gene_id + ' y1000_id=' + y1000_id + ' gene_id=' + gene_id +'\\n')\n",
    "# #                         f.write(str(cds_seq) + '\\n')  #I wonder why some of the bases were in lower case\n",
    "\n",
    "# #             else:   #if not(genome_name in missing_specs):    could also include a missing species list\n",
    "# #                 #load gene_id map based on the species\n",
    "# #                 gene_lookup_spec_fname = y1000plus_dir + os.path.normpath(\"y1000plus_tools_data/y1000plus/id_lookups/\" + genome_name + '.csv')\n",
    "# #                 gene_lookup_spec = pd.read_csv(gene_lookup_spec_fname, index_col='y1000_id')\n",
    "\n",
    "# #                 #Extract peptide sequences from peptide fasta from genome\n",
    "# #                 cds_dir = os.path.normpath(y1000plus_dir + 'shen_2018_data/0_332yeast_genomes/332_genome_annotations/cds') + os.sep \n",
    "\n",
    "# #                 cds_fname = cds_dir + genome_name + '.max.cds'\n",
    "\n",
    "# #                 seq_records = SeqIO.parse(cds_fname, \"fasta\")\n",
    "\n",
    "# #                 genes_lookup = gene_lookup_spec.loc[genes]\n",
    "# #                 genes_lookup_set = set(gene_lookup_spec.loc[genes,'gene_full'].values)\n",
    "\n",
    "# #                 for seq_record in seq_records:\n",
    "# #                     #gene_full = 'augustus_masked-Deha2C-processed-gene-4.36'\n",
    "# #                     gene_full = seq_record.description.split()[1].split('=')[1]\n",
    "# #                     #print(gene_full)\n",
    "# #                     if (gene_full in genes_lookup_set):\n",
    "# #                         #find which y1000_id was matched\n",
    "# #                         y1000_rlookup = genes_lookup['gene_full'] == gene_full\n",
    "# #                         for gene, tf in y1000_rlookup.items(): \n",
    "# #                             if tf:\n",
    "# #                                 y1000_id=gene\n",
    "# #                         gene_id = genes_lookup.loc[y1000_id, 'gene_id']\n",
    "# #                         cds_seq = seq_record.seq\n",
    "# #                         f.write('>' + genome_name + '_' + gene_id + ' y1000_id=' + y1000_id + ' gene_full=' + gene_full +\n",
    "# #                                 ' ' + seq_record.description.split()[2] + #this adds in the cds from the original description\n",
    "# #                                 '\\n')\n",
    "# #                         f.write(str(cds_seq) + '\\n')  #I wonder why some of the bases were in lower case\n",
    "\n",
    "# #     return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#ideally change to something like this: \n",
    "#>Alloascoidea_hylecoeti|0_1963  identifier_proteome_id=-augustus-gene-10.125-mRNA-1_1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# ## Make Codon based genes sets, align them and make phylogenetic trees\n",
    "# og_fname = base_dir + os.sep + 'og_metadata.json'\n",
    "# with open(og_fname, 'r') as f:\n",
    "#     og_out_data_full = json.load(f) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from Bio.Blast.Applications import NcbimakeblastdbCommandline\n",
    "from Bio.Blast.Applications import NcbiblastpCommandline\n",
    "\n",
    "cline = NcbimakeblastdbCommandline(dbtype=\"prot\",\n",
    "                                   input_file=\"NC_005816.faa\")\n",
    "cline\n",
    "NcbimakeblastdbCommandline(cmd='makeblastdb', dbtype='prot', input_file='NC_005816.faa')\n",
    "print(cline)\n",
    "makeblastdb -dbtype prot -in NC_005816.faa\n",
    "\n",
    "\n",
    "cline = NcbiblastpCommandline(query=\"rosemary.pro\", db=\"nr\",\n",
    "                              evalue=0.001, remote=True, ungapped=True)\n",
    "cline\n",
    "NcbiblastpCommandline(cmd='blastp', query='rosemary.pro', db='nr', evalue=0.001, remote=True, ungapped=True)\n",
    "print(cline)\n",
    "blastp -query rosemary.pro -db nr -evalue 0.001 -remote -ungapped\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#     if check_gene: \n",
    "#         print(str(N) + ' ' + genename_study1)\n",
    "#         AA_seqs_study2 = SeqIO.parse(AA_seqs_fnames[study2], \"fasta\")\n",
    "#         pairwise_score_comps = {}\n",
    "#         for seq_study2 in AA_seqs_study2: \n",
    "#             genename_study2 = seq_study2.id\n",
    "#             score = pairwise2.align.globalms(seq_study2,seq_study1, match_points, mismatch_points, gap_open, gap_extension, penalize_end_gaps = True, score_only = True )\n",
    "#             pairwise_score_comps[genename_study2] = score\n",
    "#         pairwise_score_comps_df = pd.Series(pairwise_score_comps)\n",
    "#         pairwise_score[genename_study1] = pairwise_score_comps_df.sort_values(ascending=False).iloc[0:NN_top_scores]\n",
    "#         #print(pairwise_score[genename_YGOB])\n",
    "#         N = N - 1\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#scer_y1000_id_gene_id_lookup = dict(zip(spec_lookup['y1000_id'], scer_lookup.index))\n",
    "    \n",
    "#Check 'quality' of sequences\n",
    "    # GC content\n",
    "    # Length of each species\n",
    "\n",
    "#Map seq from shen genomes to our genomes. \n",
    "\n",
    "#Make Metadata for each orthogroup\n",
    "# SC Genenames, SP genenames, CA genenames\n",
    "# Total number\n",
    "# Percent of species covered\n",
    "# Pathways\n",
    "# Enzyme numbers\n",
    "\n",
    "#Fasta with Sc, Sp, and Calb removed\n",
    "\n",
    "# maybe later\n",
    "# PCT Conservation (if I do MSA for each?)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Quantify information for SGD annotation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#For each of the 11 species\n",
    "\n",
    "spec_source = 'Calb'\n",
    "spec_target = 'Scer'\n",
    "\n",
    "eggnog_path = 'eggnog_mapper' + os.sep + 'proteomics_set' + os.sep\n",
    "\n",
    "eggnog_orths = pd.read_csv(base_dir + os.sep + eggnog_path + spec_source + '_' + spec_target + '_annot.csv')\n",
    "\n",
    "#for both genomes\n",
    "\n",
    "#Show how many map to something, how many map to S.cer\n",
    "\n",
    "#EC percentage for each one"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#ENA Species - this code is not used anymore as I was able to get the cds' from ncbi\n",
    "\n",
    "#With Nir's Help I ran a routine to use emboss extract_features on the embl files \n",
    "\n",
    "#First installed emboss on WSL\n",
    "#sudo apt-get emboss\n",
    "#Needed to run it with some updates because it didn't install the first time.\n",
    "#\n",
    "#Then made a script, ena_cds_extract.py to extract and provide Uniprot names\n",
    "#\n",
    "#ran with\n",
    "#python3 ./ena_cds_extract.py from the folder with the scrip\n",
    "#\n",
    "#The files were originally downloaded in Oct 2022 from:\n",
    "\n",
    "# W. anomalus: https://www.ebi.ac.uk/ena/browser/view/GCA_001661255.1?show=blobtoolkit\n",
    "# H. osmophila: https://www.ebi.ac.uk/ena/browser/view/GCA_001747045.1?show=blobtoolkit\n",
    "# C. tropicalis: https://www.ebi.ac.uk/ena/browser/view/GCA_000006335.3?show=blobtoolkit\n",
    "\n",
    "#Also extracted the genome (.fasta and embl version - changed the extension of the embl version from .txt to .embl) and put it into the appropriate folder\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# #make cds files with uniprot names as keys\n",
    "# ena_speclist = [('wickerhamomyces_anomalus','GCA_001661255.1'),\n",
    "#                 ('candida_tropicalis','GCA_000006335.3'),\n",
    "#                 ('yHMPu5000034957_hanseniaspora_osmophila_160519','GCA_001747045.1')\n",
    "#                ]\n",
    "\n",
    "# for spec, gca_name in ena_speclist:\n",
    "#     cds_raw_fname = genomes_base + os.sep + os.path.normpath('diverse_yeast/ena/' + spec + '/' + 'cds_raw.fasta')\n",
    "#     cds_out_fname = genomes_base + os.sep + os.path.normpath('diverse_yeast/ena/' + spec + '/' + 'cds.fasta')\n",
    "    \n",
    "#     cds_raw = SeqIO.parse(cds_raw_fname, 'fasta')\n",
    "    \n",
    "#     with open(cds_out_fname, 'w') as f_cds_out:\n",
    "    \n",
    "#         for record in cds_raw: \n",
    "#             db_xref_list = record.description.split('(')[1].split(')')[0].split(', ')\n",
    "#             db_xref_dict = {}\n",
    "#             for db_xref_item in db_xref_list: \n",
    "#                 (xref_db, xref_id) = db_xref_item.split('=')[1].strip('\"').split(':')\n",
    "#                 db_xref_dict[xref_db] = xref_id\n",
    "            \n",
    "#             if 'UniProtKB/TrEMBL' in db_xref_dict.keys():\n",
    "#                 id_field = 'UniProtKB/TrEMBL'\n",
    "#             elif 'UniProtKB/Swiss-Prot' in db_xref_dict.keys():\n",
    "#                 id_field =  'UniProtKB/Swiss-Prot'\n",
    "#             else:     \n",
    "#                 print(db_xref_dict.keys())\n",
    "                \n",
    "#             if 'EnsemblGenomes-Gn' in db_xref_dict.keys():\n",
    "#                 ena_id = db_xref_dict['EnsemblGenomes-Gn']\n",
    "#             else: \n",
    "#                 ena_id = 'None'\n",
    "                \n",
    "            \n",
    "#             f_cds_out.write('>' + db_xref_dict[id_field] + ' ena_id=' + ena_id + ' cds_raw_id=' + record.id + '\\n')\n",
    "#             f_cds_out.write(str(record.seq) + '\\n')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#The following code didn't work to use biopython to extract ids from .embl files\n",
    "#Kept getting Unexpected content after SQ or CO line: 'XX'\n",
    "\n",
    "# embl_in = genomes_base + os.sep + os.path.normpath('diverse_yeast/ena/candida_tropicalis/GCA_000006335.3.embl')\n",
    "# #genomes_base + os.sep + os.path.normpath('ena/wickerhamomyces_anomalus/GCA_001661255.1.embl')\n",
    "\n",
    "\n",
    "# cds_out = genomes_base + os.sep + os.path.normpath('diverse_yeast/ena/wickerhamomyces_anomalus/GCA_001661255.1.cds.uniprot_ids.fasta')\n",
    "# prot_out = genomes_base + os.sep + os.path.normpath('diverse_yeast/ena/wickerhamomyces_anomalus/GCA_001661255.1.prot.uniprot_ids.fasta')\n",
    "\n",
    "# with open(embl_in, 'r') as embl_handle:\n",
    "#     with open(cds_out, 'w') as f_cds: \n",
    "#         with open(prot_out,'w') as f_prot: \n",
    "#             for record in SeqIO.parse(embl_handle, \"embl\"):\n",
    "#                 q = 1+1\n",
    "\n",
    "# #Emboss installation https://emboss.sourceforge.net/download/\n"